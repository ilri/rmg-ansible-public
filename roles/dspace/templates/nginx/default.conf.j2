{# just in case the host doesn't have this defined, can't go in role defaults because it messes up inheritance for some playbooks #}
{% set nginx_server_name    = nginx_server_name | default("localhost") %}

# Handle old DSpace domains (redirect to ILRI community)
#
server {
    listen 80;
    server_name mahider.cgiar.org;

    location / {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/10568/1;
    }

    include extra-security.conf;
}

# Handle old CGIAR Library URLs
# ... check Google for "inurl:library.cgiar.org"
#
server {
    listen 80;
    listen [::]:80;

    server_name library.cgiar.org;

    # translate community / collection / item handles from library.cgiar.org to {{ nginx_server_name }}
    # test: http://library.cgiar.org/handle/10947/4258
    location ~ ^/handle/(.*)$ {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/$1;
    }

    # translate bitstream links from library.cgiar.org to {{ nginx_server_name }}
    # test: http://library.cgiar.org/bitstream/handle/10947/2699/CGIAR_Branding_Guidelines_and_Toolkit.pdf
    location ~ ^/bitstream {
        # ? in rewrite makes sure nginx doesn't append query string again
        # see: http://wiki.nginx.org/NginxHttpRewriteModule#rewrite
        rewrite ^ https://{{ nginx_server_name }}$request_uri? {% if nginx_redirect_type == 301 %}permanent{% else %}redirect{% endif %};
    }

    # translate top-level CGIAR Library requests to their community on {{ nginx_server_name }}
    # test: http://library.cgiar.org
    location / {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/10568/83389;
    }

    include extra-security.conf;
}

{% if nginx_library_tls_cert is defined %}
# HTTPS vhost for CGIAR Library, needs to handle the same redirects
# as the non-HTTPS vhost above, but on HTTPS.
server {
    listen {{ nginx_ssl_port }} ssl http2;
    listen [::]:{{ nginx_ssl_port }} ssl http2;

    server_name library.cgiar.org;

    ssl_certificate {{ nginx_library_tls_cert }};
    ssl_certificate_key {{ nginx_library_tls_key }};

    ssl_session_timeout {{ nginx_ssl_session_timeout }};
    ssl_session_cache {{ nginx_ssl_session_cache }};
    ssl_buffer_size {{ nginx_ssl_buffer_size }};
    ssl_dhparam {{ nginx_ssl_dhparam }};
    ssl_protocols {{ nginx_ssl_protocols }};
    ssl_ciphers "{{ tls_cipher_suite }}";
    ssl_prefer_server_ciphers on;

    # nginx does not auto-rotate session ticket keys: only a HUP / restart will do so and
    # when a restart is performed the previous key is lost, which resets all previous
    # sessions. The fix for this is to setup a manual rotation mechanism:
    # http://trac.nginx.org/nginx/changeset/1356a3b9692441e163b4e78be4e9f5a46c7479e9/nginx
    #
    # Note that you'll have to define and rotate the keys securely by yourself. In absence
    # of such infrastructure, consider turning off session tickets:
    ssl_session_tickets off;

    # translate community / collection / item handles from library.cgiar.org to {{ nginx_server_name }}
    # test: https://library.cgiar.org/handle/10947/4258
    location ~ ^/handle/(.*)$ {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/$1;
    }

    # translate bitstream links from library.cgiar.org to {{ nginx_server_name }}
    # test: https://library.cgiar.org/bitstream/handle/10947/2699/CGIAR_Branding_Guidelines_and_Toolkit.pdf
    location ~ ^/bitstream {
        # ? in rewrite makes sure nginx doesn't append query string again
        # see: http://wiki.nginx.org/NginxHttpRewriteModule#rewrite
        rewrite ^ https://{{ nginx_server_name }}$request_uri? permanent;
    }

    # translate top-level CGIAR Library requests to their community on {{ nginx_server_name }}
    # test: https://library.cgiar.org
    location / {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/10568/83389;
    }

    include extra-security.conf;
}
{% endif %} {# end: nginx_library_tls_cert #}

# Handle old Mahider URLs
# ... check Google for "inurl:mahider.ilri.org -inurl:https"
# ... check Google for "inurl:dspace.ilri.org -inurl:https"
#
server {
    listen 80;

    server_name mahider.ilri.org dspace.ilri.org;

    # links with /jspui/blah/blah should be -> /blah/blah
    location ~ ^/jspui/(.*)$ {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/$1;
    }

    # links with /jspui should go to ILRI's community
    location ~ ^/jspui$ {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/10568/1;
    }

    # translate mahider communities / collections / handles to cgspace
    location ~ ^/handle/(.*)$ {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/$1;
    }

    # make old bitstream links work
    location ~ ^/bitstream {
        # ? in rewrite makes sure nginx doesn't append query string again
        # see: http://wiki.nginx.org/NginxHttpRewriteModule#rewrite
        rewrite ^ https://{{ nginx_server_name }}$request_uri? {% if nginx_redirect_type == 301 %}permanent{% else %}redirect{% endif %};
    }

    # make old mahider.ilri.org RSS links work (ie FeedBurner)
    location ~ ^/feed/(.*)$ {
        # redirect to cgspace on non-HTTPS, because FeedBurner doesn't support HTTPS
        return {{ nginx_redirect_type }} http://{{ nginx_server_name }}/feed/$1;
    }

    location / {
        return {{ nginx_redirect_type }} https://{{ nginx_server_name }}/handle/10568/1;
    }

    include extra-security.conf;
}

{% if nginx_tls_cert is defined %}
# Handle cgspace.cgiar.org http -> https
#
server {
    listen 80;
    listen [::]:80;
    server_name {{ nginx_server_name }};

    # feedburner doesn't support https :(
    location ~ /(feed|open-search/discover) {
        # Send requests to Tomcat
        proxy_pass http://127.0.0.1:8443;
    }

    # redirect http -> https
    location / {
        # ? in rewrite makes sure nginx doesn't append query string again
        # see: http://wiki.nginx.org/NginxHttpRewriteModule#rewrite
        rewrite ^ https://{{ nginx_server_name }}$request_uri? {% if nginx_redirect_type == 301 %}permanent{% else %}redirect{% endif %};
    }

    include extra-security.conf;
}
{% endif %} {# end: nginx_tls_cert #}

{# this vhost only really needs to run in one place, so only run it if the current host has the certs #}
{% if nginx_ilri_tls_cert is defined %}
# Handle HTTPS links for non-authoritative domains from Google Scholar, ie
# dspace.ilri.org or mahider.ilri.org
# ... check Google for "inurl:mahider.ilri.org inurl:https"
# ... check Google for "inurl:dspace.ilri.org inurl:https"
server {
    listen 443 ssl http2;
    server_name dspace.ilri.org mahider.ilri.org;

    ssl_certificate {{ nginx_ilri_tls_cert }};
    ssl_certificate_key {{ nginx_ilri_tls_key }};

    ssl_session_timeout {{ nginx_ssl_session_timeout }};
    ssl_session_cache {{ nginx_ssl_session_cache }};
    ssl_buffer_size {{ nginx_ssl_buffer_size }};
    ssl_dhparam {{ nginx_ssl_dhparam }};
    ssl_protocols {{ nginx_ssl_protocols }};
    ssl_ciphers "{{ tls_cipher_suite }}";
    ssl_prefer_server_ciphers on;

    # nginx does not auto-rotate session ticket keys: only a HUP / restart will do so and
    # when a restart is performed the previous key is lost, which resets all previous
    # sessions. The fix for this is to setup a manual rotation mechanism:
    # http://trac.nginx.org/nginx/changeset/1356a3b9692441e163b4e78be4e9f5a46c7479e9/nginx
    #
    # Note that you'll have to define and rotate the keys securely by yourself. In absence
    # of such infrastructure, consider turning off session tickets:
    ssl_session_tickets off;

    # Add header to forbid robots to index
    # See: https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag
    # May, 2015 we submitted a "Change of Address" -> cgspace.cgiar.org in Google Webmaster tools
    # but I don't see any reason to let ANY bots try to index this site.
    add_header X-Robots-Tag "none";

    # redirect to {{ nginx_server_name }}
    location / {
        # ? in rewrite makes sure nginx doesn't append query string again
        # see: http://wiki.nginx.org/NginxHttpRewriteModule#rewrite
        rewrite ^ https://{{ nginx_server_name }}$request_uri? {% if nginx_redirect_type == 301 %}permanent{% else %}redirect{% endif %};
    }
}
{% endif %} {# end: nginx_ilri_tls_cert #}


# HTTPS server (only for domains we have a cert for)
#
server {
    {% if nginx_tls_cert is defined %}
    listen {{ nginx_ssl_port }} ssl http2;
    listen [::]:{{ nginx_ssl_port }} ssl http2;
    {% else %}
    listen 80;
    listen [::]:80;
    {% endif %} {# end: nginx_tls_cert #}

    server_name {{ nginx_server_name }};

    root {{ nginx_root }};

    {% if nginx_forbid_robots == True %}
    # Add header to forbid robots to index
    # See: https://developers.google.com/webmasters/control-crawl-index/docs/robots_meta_tag
    add_header X-Robots-Tag "none";
    {% endif %}

    {% if nginx_tls_cert is defined %}
    ssl_certificate {{ nginx_tls_cert }};
    ssl_certificate_key {{ nginx_tls_key }};

    ssl_session_timeout {{ nginx_ssl_session_timeout }};
    ssl_session_cache {{ nginx_ssl_session_cache }};
    ssl_buffer_size {{ nginx_ssl_buffer_size }};
    ssl_dhparam {{ nginx_ssl_dhparam }};
    ssl_protocols {{ nginx_ssl_protocols }};
    ssl_ciphers "{{ tls_cipher_suite }}";
    ssl_prefer_server_ciphers on;

    {% if ansible_distribution == 'Ubuntu' and ansible_distribution_version | version_compare('16.04', '>=') %}
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver {{ nginx_ssl_stapling_resolver }};
    {% endif %}

    # nginx does not auto-rotate session ticket keys: only a HUP / restart will do so and
    # when a restart is performed the previous key is lost, which resets all previous
    # sessions. The fix for this is to setup a manual rotation mechanism:
    # http://trac.nginx.org/nginx/changeset/1356a3b9692441e163b4e78be4e9f5a46c7479e9/nginx
    #
    # Note that you'll have to define and rotate the keys securely by yourself. In absence
    # of such infrastructure, consider turning off session tickets:
    ssl_session_tickets off;

    {% if nginx_enable_hsts == True %}
    # Enable this if you want HSTS (recommended, but be careful)
    add_header Strict-Transport-Security max-age=15768000;
    {% endif %} {# end: nginx_enable_hsts #}
    {% endif %} {# end: nginx_tls_cert #}

    # static assets we can load from the file system directly with nginx
    location ~ /(themes|aspects/ReportingSuite|aspects/Statistics) {
        try_files $uri @tomcat;

        location ~* \.(?:ico|css|js|gif|jpe?g|png|woff)$ {
            add_header Cache-Control "public, max-age=604800";
        }
    }

    # block robots from crawling dynamic URLs (because we can't use * in robots.txt!)
    # see: https://jira.duraspace.org/browse/DS-2962
    location ~ /handle/[0-9]+/[0-9]+/(browse|discover|search-filter) {
        add_header X-Robots-Tag "none";
        proxy_pass http://tomcat_http;
    }

    location / {
        # Send requests to Tomcat
        proxy_pass http://tomcat_http;
    }

    # log rest requests
    location /rest {
        access_log /var/log/nginx/rest.log;
        proxy_pass http://tomcat_http;
    }

    # log oai requests
    location /oai {
        access_log /var/log/nginx/oai.log;
        proxy_pass http://tomcat_http;
    }

    # Only allow Solr access from localhost
    location /solr {
        allow 127.0.0.1;
        deny all;
    }

    # Only allow access to management contexts from localhost (for Munin tomcat)
    location ~ /(host-manager|manager) {
        allow 127.0.0.1;
        deny all;
    }

    # Only allow jspui access for atmire modules
    location /jspui {
        location ~ ^/jspui/(export|listings-and-reports) {
            allow all;
            proxy_pass http://tomcat_http;
        }

        deny all;
    }

    # named location for above try_files
    location @tomcat {
        proxy_pass http://tomcat_http;
    }

    include extra-security.conf;
}

upstream tomcat_http {
    {% if nginx_tls_cert is defined %}
    server 127.0.0.1:8443;
    {% else %}
    server 127.0.0.1:8001;
    {% endif %}

    # The keepalive parameter sets the maximum number of idle keepalive connections
    # to upstream servers that are preserved in the cache of each worker process. When
    # this number is exceeded, the least recently used connections are closed.
    keepalive 60;
}

# vim: set ts=4 sw=4:
